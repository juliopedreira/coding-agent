# Epic 5: Conversation & Session Manager

## Functional Analysis & Design
- Maintain live session state (history + runtime settings) across turns: messages (user/assistant/tool), model id, reasoning_effort, fs_mode, approval_policy, session_id.
- Provide slash-command handling to mutate state at runtime: `/newsession`, `/model <id>`, `/reasoning <level>`, `/approvals <never|on-request|always>`, `/fsmode <restricted|unrestricted>`, `/help`, `/quit`.
- Start new sessions cleanly: persist prior session transcript/log; generate new session_id; reset history and PTY resources.
- Integrate with OpenAI Responses client (Epic 3) to assemble request payloads and stream events back into history while honoring tool advertisement (Epic 4).
- Expose a clean API surface for the TUI (Epic 6) to send user input, receive streamed events, inspect current state, and list/resume/delete sessions.
- Persist conversations to JSONL (Epic 2 schema) and session logs; support resume flow that restores history and state.
- Keep default approval policy/model/fs_mode from loaded `Settings`; session-level overrides via slash commands do not mutate the config file.

## Technical Analysis & Design
- **State model**
  - `SessionState`: immutable dataclass holding `session_id`, `settings` (model, reasoning_effort, fs_mode, approval_policy), `history` (list of messages/events), `open_tool_sessions` (PTY ids), `metadata` (timestamps).
  - `ConversationManager`: orchestrates state transitions, slash commands, persistence hooks, and OpenAI client interaction.
- **Message/history representation**
  - Store tool calls as separate `tool` role messages (per Q&A decision) alongside `user` and `assistant` messages; retain tool_call_id linkage.
  - Messages carry `content`, `role`, optional `tool_call_id`, and `metadata` (request_id, truncation flags).
  - Optionally track `response_id`/`request_id` to correlate with OpenAI client for logging and replay.
- **Slash command handling**
  - Parse leading `/`; validate commands and arguments; return structured `CommandResult` with user-facing feedback.
  - `/newsession`: flush current JSONL/log, close PTYs, create new `session_id`, clear history/state.
  - `/model`, `/reasoning`, `/approvals`, `/fsmode`: update state fields; validate against enums; persist change event.
  - `/help`: return list of commands; `/quit`: trigger graceful shutdown hook.
- **Request assembly & streaming**
  - Build `ConversationRequest` using current history + advertised tools; attach session_id/trace_id metadata.
  - Feed stream from OpenAI client into `ConversationManager` which updates history incrementally: append deltas, tool call starts, tool outputs, final assistant message.
  - Surface structured events to TUI: `TokenDelta`, `ToolStarted`, `ToolOutput`, `AssistantComplete`, `Error`.
- **Persistence**
  - On each significant event, append to JSONL via Epic 2 writer; ensure append-only and crash-safe.
  - Plaintext session logger records high-level events/errors.
  - Resume flow: load JSONL, reconstruct `history` and `SessionState` (including last settings); use Epic 2 `list_sessions`/`resume_session`; ignore unknown fields gracefully.
  - Session IDs generated via Epic 2 helper (`YYYYMMDDHHMM-uuid4`) to stay sortable/unique.
- **Session lifecycle & shutdown**
  - Hook into `shutdown.py` to flush writers, close PTYs, and mark session end.
  - Provide `list_sessions`/`resume_session`/`delete_session` facades over Epic 2 helpers for TUI/CLI use.
- **Error handling**
  - Validation errors (bad slash args) return user feedback without mutating state.
  - OpenAI/client errors recorded in history and log; exposed to UI as events.
  - Enforce fs_mode/approval_policy by delegating to tools layer; manager passes current state through to tool advertisements and shell/pty invocations.
- **Configuration flow**
  - Initial state seeded from `Settings` (Epic 2); slash commands override session-local state; not persisted back to config file.
  - Expose `get_state()` snapshot for TUI status bar (model, reasoning_effort, fs_mode, approval_policy, session_id).
  - Optional history trimming guard (e.g., keep last N messages in-memory while persisting all) to avoid runaway RAM; default unlimited unless memory pressure observed.

## Architecture
- New package `lincona/conversation/`:
  - `state.py`: `SessionState`, message/event models, helpers to apply deltas.
  - `manager.py`: `ConversationManager` with APIs: `handle_user_input(text)`, `handle_slash(cmd)`, `stream_assistant_reply()`, `get_state()`, `list_sessions()/resume()/delete()`.
  - `commands.py`: slash command parsing/validation and `CommandResult`.
  - `events.py`: event types emitted to TUI (token delta, tool events, errors).
- Integration:
  - Uses `lincona.config.Settings`, `lincona.sessions` (Epic 2), `lincona.logging`, `lincona.openai_client` (Epic 3), and `lincona.tools` specs (Epic 4).
  - TUI consumes `events` stream; OpenAI client invoked via manager.

## Implementation Steps (sequential checklist)
[ ] Add `lincona/conversation/state.py` defining `SessionState`, message/event models, helpers to append user/assistant/tool messages.
[ ] Add `lincona/conversation/commands.py` to parse/validate slash commands and return `CommandResult` with status + feedback.
[ ] Add `lincona/conversation/events.py` defining UI-facing streamed event types (`TokenDelta`, `ToolStarted`, `ToolOutput`, `AssistantComplete`, `Error`).
[ ] Implement `ConversationManager` in `lincona/conversation/manager.py` handling user input, slash commands, OpenAI request assembly, streaming updates into history, and persistence writes.
[ ] Wire persistence: use Epic 2 JSONL writer/logger to append events and session metadata; implement resume/list/delete helpers.
[ ] Integrate shutdown hooks to flush writers and close PTYs when sessions end or `/quit` received.
[ ] Add unit tests for slash command parsing, state transitions, history reconstruction on resume, streaming event application, and error paths.
[ ] Update docs (`README` or dev notes) and tick Epic 5 in `docs/mvp_00/01_PLAN.md` after implementation.

## Q&A Log
- Q1: How should the session manager persist tool-call results in the conversation history? **Answer:** a) Store tool calls as separate `tool` role messages alongside assistant/user messages.
