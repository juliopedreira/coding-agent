# Epic 4: Tooling Core & Filesystem Boundaries

## Functional Analysis & Design
- Enforce filesystem boundaries according to `fs_mode` for all model-facing tools so no operation escapes the allowed root.
- Provide core tools the model can invoke via Responses tools: `list_dir`, `read_file`, `grep_files`, `apply_patch_json`, `apply_patch_freeform`, `shell`, `exec_command`, `write_stdin`.
- Cap tool outputs (stdout/stderr) to prevent UI/model overload, adding a clear `[truncated]` marker when limits are hit.
- Respect `approval_policy` (default `never`, meaning no prompts) but structure hooks so future policies can block/allow mutating tools.
- Emit structured tool-call events consumable by persistence and UI for visibility (start, success/fail, truncation).
- Aligns with MVP_00 specification; the only intentional deviation is disabling git-root auto-detection for `restricted` mode (root is process cwd per Q&A decision).

## Technical Analysis & Design
- **Filesystem boundary**
  - `FsBoundary` helper resolves and validates paths against allowed root.
  - Root selection per decision: in `restricted` mode root = process cwd (no git-root override, explicit deviation from MVP note); `unrestricted` allows any absolute path.
  - Path handling: normalize (`resolve(strict=False)`), reject symlink escapes by resolving final path and ensuring it remains under root; disallow `..` escapes.
  - Validation functions: `assert_within_root(path)`, `sanitize_workdir(path|None)` returning safe absolute path or raising `FsViolationError`.
- **Tool surfaces (call-level contracts)**
  - `list_dir(path=".", depth=2, offset=0, limit=200)`: breadth-first listing up to depth, sorted, one entry per line with type markers (/, *, @).
  - `read_file(path, offset=0, limit=400, mode="slice"|"indentation")`: slice by lines, optional indentation prefix for readability; trims lines over 400 chars with `… [truncated line]`.
  - `grep_files(pattern, path=".", include=None, limit=200)`: recursive regex search using pure-Python `re` (no ripgrep dependency) with optional include globs; returns file:line:match lines; stop after limit matches.
  - `apply_patch_json(patch:str)`: validate unified diff, ensure all target files within root, apply atomically (write to temp then move); reject if fuzz/offset required; report per-file stats.
  - `apply_patch_freeform`: parse Codex envelope `*** Begin Patch ... *** End Patch`, extract diff, delegate to JSON patch applier.
  - `shell(command, workdir=None, timeout_ms=60000)`: run via user shell, capture stdout/stderr, enforce workdir within root (if restricted), apply output caps (8KB or 200 lines).
  - `exec_command(cmd, workdir=None, yield_time_ms=250, max_output_tokens=8000)`: start PTY-backed subprocess, register session id, stream incremental output with caps and truncation markers.
  - `write_stdin(session_id, chars, yield_time_ms=250, max_output_tokens=8000)`: write to existing PTY session, return streamed output; close on EOF or explicit command.
- **Output caps & truncation**
  - Shared limiter: cap to 8KB or 200 lines (whichever first) for stdout and stderr independently; append `[truncated]`.
  - For streamed PTY, cap per poll and cumulatively per request to avoid runaway memory.
- **Approval policy hooks**
  - `ApprovalPolicy` from config drives pre-check: mutating tools (`apply_patch*`, `shell`, `exec_command`, `write_stdin`) pass through `approval_guard(policy, tool_name)`; default `never` returns allow; structure to plug interactive prompt later.
- **Error handling & reporting**
  - Typed errors: `FsViolationError`, `PatchParseError`, `PatchApplyError`, `CommandTimeoutError`, `CommandFailedError`, `ToolValidationError`.
  - Tool responses carry status, message, truncated flag, and for mutating tools a summary of changes (files touched, bytes written).
  - Ensure non-zero shell exit codes are surfaced but still return collected output.
- **Atomic patch application**
  - Parse unified diff; for each file, load original, apply hunks strictly; write to `tmp` sibling file; `fsync` then `replace` to commit atomically.
  - Reject creation/deletion outside root; allow new files if parent dirs inside root.
- **PTY/session management**
  - `PtyManager` keeps a map session_id → PTY subprocess + queue; enforces initial workdir validation; cleans up on session end or SIGINT via shutdown hooks.
- **Integration points**
  - Tool functions exposed as callables and as tool specs (JSON + freeform) for OpenAI advertisement (Epic 3).
  - Emits structured events (start/end/error, bytes/lines, truncated) for persistence/logging modules from Epic 2.

## Architecture
- New package `lincona/tools/`:
  - `fs.py`: `FsBoundary`, `FsViolationError`, path validation utilities.
  - `limits.py`: output/line truncation helpers shared by tools.
  - `list_dir.py`, `read_file.py`, `grep_files.py`, `apply_patch.py`, `shell.py`, `exec_pty.py`: tool implementations.
  - `patch_parser.py`: unified diff + freeform envelope parsing.
  - `approval.py`: `approval_guard` shim using `ApprovalPolicy`.
  - `router.py`: register tool specs for OpenAI Responses, dispatch to implementations, produce structured results.
- Extend `lincona/shutdown.py` to close PTY sessions on exit.
- Wire to config (`FsMode`, `ApprovalPolicy`) for runtime behavior; reuse `paths.get_lincona_home` only for default locations, not boundary root.

## Implementation Steps (sequential checklist)
[ ] Add `lincona/tools/fs.py` with `FsBoundary` (root selection, path normalization, symlink escape checks) and `FsViolationError`.
[ ] Add `lincona/tools/limits.py` for shared byte/line truncation utilities and markers.
[ ] Implement file tools: `list_dir.py`, `read_file.py`, `grep_files.py` using `FsBoundary`.
[ ] Implement patch tooling: `patch_parser.py` (unified + freeform envelope) and `apply_patch.py` with atomic apply and root enforcement.
[ ] Implement command tooling: `shell.py` (with timeouts, caps, exit status) and `exec_pty.py` (PTY manager, exec_command, write_stdin).
[ ] Add `approval.py` guard and integrate into mutating tools.
[ ] Add `router.py` to expose tool specs (JSON + freeform apply_patch) and dispatch functions, emitting structured results/events.
[ ] Integrate PTY cleanup into `shutdown.py`; ensure errors surface via typed exceptions.
[ ] Add unit tests for fs boundary enforcement, symlink escape rejection, truncation behavior, patch parsing/apply, shell timeout/non-zero exit, PTY lifecycle, and approval guard.
[ ] Update docs (`README` or dev notes) and tick Epic 4 in `docs/mvp_00/01_PLAN.md` once implemented.

## Q&A Log
- Q1: In `restricted` fs_mode, what is the allowed root? **Answer:** Always the process cwd passed by the user (no git-root override).
